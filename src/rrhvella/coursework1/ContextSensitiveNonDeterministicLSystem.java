package rrhvella.coursework1;

import java.util.HashMap;
import java.util.LinkedList;
import java.util.Random;
import java.util.Set;

/**
 * Specifies a context-sensitive stochastic L-system. A description of such a
 * system is given in the essay submitted for the first part of this coursework.
 */
public class ContextSensitiveNonDeterministicLSystem {
	/**
	 * The productions for this grammar.
	 */
	private HashMap<ContextSensitiveNonDeterministicPredecessor, String> productions;
	/**
	 * The string generated by the last iteration.
	 */
	protected String currentString;
	/**
	 * The axiom for this grammar.
	 */
	private String axiom;
	/**
	 * The set of predecessors for the productions of this grammar.
	 */
	private Set<ContextSensitiveNonDeterministicPredecessor> predecessors;
	/**
	 * The random number generator used to simulate stochastic processes in this
	 * system.
	 */
	private Random randomGenerator;
	/**
	 * The value of the flag, 'change entire context'.
	 * 
	 * @see ContextSensitiveNonDeterministicLSystem#ContextSensitiveNonDeterministicLSystem(String,
	 *      HashMap, boolean)
	 */
	private boolean changeEntireContext;

	/**
	 * 
	 * @author Stark
	 * 
	 *         This inner class is used to map a predecessor, from this
	 *         grammar's products, to a probability index.
	 * @see ContextSensitiveNonDeterministicLSystem#process(String)
	 */
	private class PredecessorProbabilityIndexPair {
		/**
		 * The predecessor in this relationship.
		 */
		public ContextSensitiveNonDeterministicPredecessor predecessor;
		/**
		 * The probability index in this relationship.
		 */
		public int probabilityIndex;

		/**
		 * 
		 * @param predecessor
		 *            the predecessor in this relationship.
		 * @param probabilityIndex
		 *            the probability index in this relationship.
		 * @see ContextSensitiveNonDeterministicPredecessor
		 */
		public PredecessorProbabilityIndexPair(
				ContextSensitiveNonDeterministicPredecessor predecessor,
				int probabilityIndex) {
			this.predecessor = predecessor;
			this.probabilityIndex = probabilityIndex;
		}
	}

	/**
	 * Returns the axiom for this grammar.
	 * 
	 * @return the axiom for this grammar.
	 */
	public String getAxiom() {
		return axiom;
	}

	/**
	 * 
	 * @param axiom
	 *            the axiom for this grammar.
	 * @param productions
	 *            the productions for this grammar as a dictionary which maps a
	 *            predecessor to its successor.
	 * @see ContextSensitiveNonDeterministicPredecessor
	 */
	public ContextSensitiveNonDeterministicLSystem(
			String axiom,
			HashMap<ContextSensitiveNonDeterministicPredecessor, String> productions) {
		this(axiom, productions, false);
	}

	/**
	 * 
	 * @param axiom
	 *            the axiom for this grammar.
	 * @param productions
	 *            the productions for this grammar, as a dictionary which maps a
	 *            predecessor to its successor.
	 * @param changeEntireContext
	 *            if true, then, at each iteration, this system will replace the
	 *            predecessor, along with its entire context, with the
	 *            successor. Otherwise, if this parameter is false, this system
	 *            will only replace the predecessor.
	 */
	public ContextSensitiveNonDeterministicLSystem(
			String axiom,
			HashMap<ContextSensitiveNonDeterministicPredecessor, String> productions,
			boolean changeEntireContext) {
		this.axiom = axiom;
		this.currentString = axiom;
		this.productions = productions;
		this.randomGenerator = new Random();
		this.changeEntireContext = changeEntireContext;

		// Get the predecessors from the keys of the productions set.
		this.predecessors = productions.keySet();
	}

	/**
	 * Process the given string according to the rewriting the rules of this
	 * grammar and return the result.
	 * 
	 * @param source
	 *            the string which will be rewritten.
	 * @return the result of the rewriting process.
	 */
	public String process(String source) {
		// The buffer which will contain the result as it is being generated.
		StringBuffer result = new StringBuffer();
		// The length of the source string.
		int stringLength = source.length();

		// For each character in the source string.
		for (int charIndex = 0; charIndex < stringLength; charIndex++) {
			/*
			 * Algorithm description:
			 * 
			 * Find the vector of valid productions R. A production is valid if
			 * and only if it fits the context starting from the current
			 * character.
			 * 
			 * Assign a probability index P(n) to each production, such that
			 * P(n) = P(n - 1) + the probability of R(n), P(-1) = 0.
			 * 
			 * To select the production for the current character, first
			 * generate a random number x, such that 1 <= x <= the number of
			 * productions. Then, iterate through R starting from the last
			 * element and moving back, until R(k) is found, such that P(k) < x.
			 * 
			 * Replace the context starting from the current character with the
			 * successor of R(k). If the 'change entire context' flag is false,
			 * then only replace the predecessor.
			 */

			// Initialise the probability index.
			int probabilityIndex = 0;

			// The rules which fit the context starting from the current
			// character.
			LinkedList<PredecessorProbabilityIndexPair> possibleRules = new LinkedList<PredecessorProbabilityIndexPair>();

			// For each predecessor.
			for (ContextSensitiveNonDeterministicPredecessor predecessor : predecessors) {
				// Confirm that the context is valid.
				if (predecessor.isContextValid(source, charIndex)) {
					// Add this rule to the list of possible rules, and
					// associate a probability index with it.
					probabilityIndex += predecessor.getProbability();
					possibleRules.add(new PredecessorProbabilityIndexPair(
							predecessor, probabilityIndex));
				}
			}

			// If no predecessor is valid, add the same character to the
			// resultant string and continue to the next loop iteration.
			if (possibleRules.size() == 0) {
				result.append(source.charAt(charIndex));
				continue;
			}

			// Randomly select one of the rules.
			int ruleSelector = randomGenerator.nextInt(probabilityIndex);
			PredecessorProbabilityIndexPair currentProbabilityIndexPair = possibleRules
					.pop();

			while (currentProbabilityIndexPair.probabilityIndex < ruleSelector + 1) {
				currentProbabilityIndexPair = possibleRules.pop();
			}

			// If the 'change entire context' flag is false, then append the
			// preceding context for this production.
			if (!changeEntireContext) {
				result.append(currentProbabilityIndexPair.predecessor
						.getPrecedingContext());
			}

			// Append the successor of the production.
			result.append(productions
					.get(currentProbabilityIndexPair.predecessor));

			// If the 'change entire context' flag is false, then append the
			// proceeding context for this production.
			if (!changeEntireContext) {
				result.append(currentProbabilityIndexPair.predecessor
						.getProceedingContext());
			}

			// If the 'change entire context' flag is true, then the context in
			// the source string should be skipped, as it will be completely
			// replaced.
			if (changeEntireContext) {
				charIndex += currentProbabilityIndexPair.predecessor
						.getContextLength() - 1;
			}

		}

		/**
		 * Return the result.
		 */
		return result.toString();
	}

	/**
	 * Processes the current string and returns the next one.
	 * 
	 * @return the next string in the system.
	 */
	public String next() {
		currentString = process(currentString);

		return currentString;
	}

	/**
	 * Reverts the current string back to the axiom.
	 */
	public void reset() {
		currentString = axiom;
	}

	/**
	 * Returns the current string.
	 * 
	 * @return the current string.
	 */
	public String getCurrentString() {
		return currentString;
	}

}
